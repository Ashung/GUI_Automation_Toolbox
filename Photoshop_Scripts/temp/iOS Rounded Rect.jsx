//// iOS Rounded Rect v1.2// For Photoshop// By Mike Swanson (http://blog.mikeswanson.com/)///*<javascriptresource><name>iOS Rounded Rect...</name><category>Mike Swanson</category></javascriptresource>*/#target photoshop// Settingsconst kMSRRPreset = app.stringIDToTypeID("msrrPreset");const kMSRRWidth = app.stringIDToTypeID("msrrWidth");const kMSRRHeight= app.stringIDToTypeID("msrrHeight");const kMSRRCornerRadius = app.stringIDToTypeID("msrrCornerRadius");const kMSRRUpperLeft = app.stringIDToTypeID("msrrUpperLeft");const kMSRRUpperRight = app.stringIDToTypeID("msrrUpperRight");const kMSRRLowerRight = app.stringIDToTypeID("msrrLowerRight");const kMSRRLowerLeft = app.stringIDToTypeID("msrrLowerLeft");const kMSRRIncludeGuides = app.stringIDToTypeID("msrrIncludeGuides");const kMSRRIncludeTemplate = app.stringIDToTypeID("msrrIncludeTemplate");const kMSRRIncludeGlitch = app.stringIDToTypeID("msrrIncludeGlitch");const kMSRRImprovedIconShape = app.stringIDToTypeID("msrrImprovedIconShape");const kMSRRSettings = "msrrSettings";// Globalsvar docRef;var resolution;var presets = ["App - iPhone Retina (120 x 120)",               "App - iPad Non-Retina (76 x 76)",               "App - iPad Retina (152 x 152)",               "-",               "Spotlight - iPhone Retina (80 x 80)",               "Spotlight - iPad Non-Retina (40 x 40)",               "Spotlight - iPad Retina (80 x 80)",               "-",               "Settings - iPhone Retina (58 x 58)",               "Settings - iPad Non-Retina (29 x 29)",               "Settings - iPad Retina (58 x 58)",               "-",               "iTunes - Artwork (1,024 x 1,024)"];var inputPreset;var inputWidth;var inputHeight;var inputCornerRadius;var inputUpperLeft;var inputUpperRight;var inputLowerRight;var inputLowerLeft;var inputIncludeGuides;var inputIncludeTemplate;var inputIncludeGlitch;var inputImprovedIconShape;// Useful functionscTID = function(s) { return app.charIDToTypeID(s); };sTID = function(s) { return app.stringIDToTypeID(s); };// Beginmain();function main() {    // Configure new dialog    var window = new Window("dialog", "iOS Rounded Rect", undefined, {borderless: false});     // Presets    var presetGroup = window.add("group");    inputPreset = presetGroup.add("dropdownlist", undefined, presets);    inputPreset.selection = 0;    inputPreset.title = "Preset:";    inputPreset.active = true;    inputPreset.onChange = function () {        applyPreset(inputPreset.selection);        updateGuidesAndTemplateOptions();    };    // Sizes and corners    var sizesAndCornersGroup = window.add("group");    // Sizes    var sizesGroup = sizesAndCornersGroup.add("group");    sizesGroup.orientation = "column";    sizesGroup.alignment = "left";    // Width field    var widthGroup = sizesGroup.add("group");    widthGroup.alignment = "right";    widthGroup.add("statictext", undefined, "Width:");    inputWidth = widthGroup.add("edittext", undefined, "");    inputWidth.characters = 8;    inputWidth.onChange = function () {        updateGuidesAndTemplateOptions();    };        // Height field    var heightGroup = sizesGroup.add("group");    heightGroup.alignment = "right";    heightGroup.add("statictext", undefined, "Height:");    inputHeight = heightGroup.add("edittext", undefined, "");    inputHeight.characters = 8;    inputHeight.onChange = function () {        updateGuidesAndTemplateOptions();    };    // Corner radius field    var cornerRadiusGroup = sizesGroup.add("group");    cornerRadiusGroup.alignment = "right";    cornerRadiusGroup.add("statictext", undefined, "Corner radius:");    inputCornerRadius = cornerRadiusGroup.add("edittext", undefined, "");    inputCornerRadius.characters = 8;    // Separator    var separatorGroup = sizesAndCornersGroup.add("group");    separatorGroup.size = [20, 20];    // Corners    var cornerGroup = sizesAndCornersGroup.add("panel", undefined, "Corners");    cornerGroup.size = [85, 88];    cornerGroup.orientation = "column";    cornerGroup.margins = [15, 15, 15, 15];        var topRow = cornerGroup.add("group");    topRow.alignment = "fill";    inputUpperLeft = topRow.add("checkbox", undefined, undefined);    inputUpperLeft.alignment = ["left", "top"];    inputUpperLeft.value = true;    inputUpperRight= topRow.add("checkbox", undefined, undefined);    inputUpperRight.alignment = ["right", "top"];    inputUpperRight.value = true;        var bottomRow = cornerGroup.add("group");    bottomRow.alignment = "fill";        inputLowerLeft = bottomRow.add("checkbox", undefined, undefined);    inputLowerLeft.alignment = ["left", "bottom"];    inputLowerLeft.value = true;    inputLowerRight = bottomRow.add("checkbox", undefined, undefined);    inputLowerRight.alignment = ["right", "bottom"];    inputLowerRight.value = true;    // Other options    var otherGroup = window.add("group");    var otherGroup1 = otherGroup.add("group");    otherGroup1.orientation = "column";        inputIncludeGuides = otherGroup1.add("checkbox", undefined, "Icon guides");    inputIncludeGuides.alignment = "left";    inputIncludeGuides.value = false;    inputIncludeTemplate = otherGroup1.add("checkbox", undefined, "Icon template");    inputIncludeTemplate.alignment = "left";    inputIncludeTemplate.value = false;    var otherGroup2 = otherGroup.add("group");    otherGroup2.orientation = "column";    inputImprovedIconShape = otherGroup2.add("checkbox", undefined, "Improved icon shape");    inputImprovedIconShape.alignment = "left";    inputImprovedIconShape.value = true;    inputImprovedIconShape.onClick = function () {        updateGuidesAndTemplateOptions();    };    inputIncludeGlitch = otherGroup2.add("checkbox", undefined, "Include UIBezier glitch");    inputIncludeGlitch.alignment = "left";    inputIncludeGlitch.value = false;        // OK and Cancel buttons    var buttonGroup = window.add("group");    buttonGroup.add("button", undefined, "OK");    buttonGroup.add("button", undefined, "Cancel");    // About text    var aboutGroup = window.add("group");    aboutGroup.orientation = "column";    aboutGroup.spacing = 0;        var aboutText1 = aboutGroup.add("statictext", undefined, "iOS Rounded Rect v1.2");    var aboutText2 = aboutGroup.add("statictext", undefined, "by Mike Swanson (blog.mikeswanson.com)");    aboutText1.graphics.foregroundColor = aboutText1.graphics.newPen(aboutText1.graphics.PenType.SOLID_COLOR, [0.5, 0.5, 0.5, 1.0], lineWidth = 1);    aboutText2.graphics.foregroundColor = aboutText2.graphics.newPen(aboutText2.graphics.PenType.SOLID_COLOR, [0.5, 0.5, 0.5, 1.0], lineWidth = 1);    // Update based on preset default    inputPreset.notify();    getSettings();    updateGuidesAndTemplateOptions();    // Show dialog    if (window.show() == 1) {        // Validate input        var width = Math.max(parseFloat(inputWidth.text), 0.0);        if (isNaN(width)) width = 0.0;        inputWidth.text = width;                var height = Math.max(parseFloat(inputHeight.text), 0.0);        if (isNaN(height)) height = 0.0;                inputHeight.text = height;                var cornerRadius = Math.max(parseFloat(inputCornerRadius.text), 0.0);        if (isNaN(cornerRadius)) cornerRadius = 0.0;                // Clamp the corner radius to a positive value that is no larger than half the rectangle's width or height        cornerRadius = Math.max(Math.min(width * 0.5, height * 0.5, cornerRadius), 0.0);        inputCornerRadius.text = cornerRadius;        saveSettings();        if (width == 0.0 || height == 0.0) {                    alert("Nothing to draw");            return;        }        // Need to create a document?        if (app.documents.length == 0) {            var documentWidth = new UnitValue(width + " pixels");            var documentHeight = new UnitValue(height + " pixels");            app.documents.add(documentWidth, documentHeight, undefined, "iOS Rounded Rect", NewDocumentMode.RGB, DocumentFill.TRANSPARENT, undefined, undefined, undefined);        }                    // Reference the active document        docRef = app.activeDocument;        // Wrap everything into a single history entry for easy undo        docRef.suspendHistory("iOS Rounded Rect Script", "process()");    }    else {                // Cancelled    }}function process() {    // Grab the active document resolution    resolution = docRef.resolution;    // Inputs have already been validated    var width = parseFloat(inputWidth.text);    var height = parseFloat(inputHeight.text);    var cornerRadius = parseFloat(inputCornerRadius.text);    // Create a new ArtLayer object    var layer = docRef.artLayers.add();     var layerName = getUniqueName("iOS Rounded Rect", docRef.artLayers);    layer.name = layerName;    layer.kind = LayerKind.NORMAL;    // Determine origin so that shape is centered in the document    var originX = Math.round((docRef.width.as("px") - width) * 0.5);    var originY = Math.round((docRef.height.as("px") - height) * 0.5);    // Add the rounded rect    createRoundedRectangle(docRef, originX, originY, width, height, cornerRadius, inputIncludeGlitch.value, inputImprovedIconShape.value);    // Only add a template or guides if we have a square shape    if (width == height &&       (inputIncludeTemplate.value || inputIncludeGuides.value)) {                // Add guides        addGuidesAndTemplate(docRef, originX, originY, width, inputIncludeGuides.value, inputIncludeTemplate.value);    }    // Set the shape layer as active    var layerToActivate = docRef.artLayers.getByName(layerName);    if (layerToActivate) {        docRef.activeLayer = layerToActivate;    }}// To create a new preset, add its description to the presets array at the top of this script. Then, add a case statement// below based on its 0-based index in the array. If you don't want the preset to compute a standard icon corner radius,// set usesStandardIconRadius to false in your case block. For example://// case 13://     size = 100;//     usesStandardIconRadius = false;//     cornerRadius = 10;//     break;function applyPreset(preset) {    var index = parseInt(preset);        var size = 0;    var cornerRadius = 0;    var usesStandardIconRadius = true;        switch (index) {             case 0:            size = 120;            break;        case 1:            size = 76;            break;        case 2:            size = 152;            break;        case 4:        case 6:            size = 80;            break;        case 5:            size = 40;            break;        case 8:        case 10:            size = 58;            break;        case 9:            size = 29;            break;        case 12:            size = 1024;            break;    }    // Assign presets    inputWidth.text = size;    inputHeight.text = size;    inputCornerRadius.text = (usesStandardIconRadius ? (Math.round(size * (34.0 / 152.0) * 2.0) / 2.0) : cornerRadius);}function updateGuidesAndTemplateOptions() {     var width = parseFloat(inputWidth.text);    if (isNaN(width)) width = 0.0;            var height = parseFloat(inputHeight.text);    if (isNaN(height)) height = 0.0;            var enabled = ((width == height) &&                   (width > 0.0));                   inputIncludeGuides.enabled = enabled;    inputIncludeTemplate.enabled = enabled;    inputIncludeGlitch.enabled = (inputImprovedIconShape.value == false);}function createRoundedRectangle(doc, originX, originY, width, height, cornerRadius, includeGlitch, improvedIconShape) {        try {                // Clamp the corner radius to a positive value that is no larger than half the rectangle's width or height        cornerRadius = Math.max(Math.min(width * 0.5, height * 0.5, cornerRadius), 0.0);        // Compute corners        var upperLeft = new Array(originX, originY);        var upperRight = new Array(originX + width, originY);        var lowerRight = new Array(originX + width, originY + height);        var lowerLeft = new Array(originX, originY + height);        // Define the path        var lineArray = new Array();        if (cornerRadius < 1) {                    // Create a simple rect            lineArray.push(newLine(upperLeft[0], upperLeft[1], undefined, undefined, undefined, undefined));            lineArray.push(newLine(upperRight[0], upperRight[1], undefined, undefined, undefined, undefined));            lineArray.push(newLine(lowerRight[0], lowerRight[1], undefined, undefined, undefined, undefined));            lineArray.push(newLine(lowerLeft[0], lowerLeft[1], undefined, undefined, undefined, undefined));        }        else {                        var f1 = 1.528665;            var f2 = 1.088492963;            var f3 = 0.868406926;            var f4 = 0.631493778;            var f5 = 0.07491137;            var f6 = 0.372823815;            var f7 = 0.169059556;                        if (improvedIconShape) {                                includeGlitch = false;    // The improved icon shape doesn't use the glitch                            f1 = 1.512996779;                f2 = 1.000822998;                f3 = 0.857108385;                f4 = 0.636612366;                f5 = 0.074140812;                f6 = 0.375930619;                f7 = 0.169408557;            }            var m = new Array(cornerRadius * f1, 0.0);            var l1 = new Array(cornerRadius * f1, 0.0);            var c1cp1 = new Array(cornerRadius * f2, 0.0);            var c1cp2 = new Array(cornerRadius * f3, 0.0);            var c1 = new Array(cornerRadius * 0.669934593, cornerRadius * 0.065495889);         // Skip to avoid glitch            var l2 = new Array(cornerRadius * f4, cornerRadius * f5);            var c2cp1 = new Array(cornerRadius * f6, cornerRadius * f7);            var c2cp2 = new Array(cornerRadius * f7, cornerRadius * f6);            var c2 = new Array(cornerRadius * f5, cornerRadius * f4);            var c3cp1 = new Array(0.0, cornerRadius * f3);            var c3cp2 = new Array(0.0, cornerRadius * f2);            var c3 = new Array(0.0, cornerRadius * f1);            // Be faithful to UIBezierPath's "glitch"?            if (!includeGlitch) {                                        c1 = l2;            }            // Initial point            var anchorX = (inputUpperLeft.value ? upperLeft[0] + m[0] : upperLeft[0]);            var anchorY = (inputUpperLeft.value ? upperLeft[1] + m[1] : upperLeft[1]);            var rightDirectionX = (inputUpperLeft.value ? upperLeft[0] + c3cp2[1] : undefined);            var rightDirectionY = (inputUpperLeft.value ? upperLeft[1] + c3cp2[0] : undefined);            lineArray.push(newLine(anchorX, anchorY,                                   undefined, undefined,                                   rightDirectionX, rightDirectionY));            if (inputUpperRight.value == true) {                // Section 1                lineArray.push(newLine(upperRight[0] - l1[0], upperRight[1] + l1[1],                                       upperRight[0] - c1cp1[0], upperRight[1] + c1cp1[1],                                       undefined, undefined));                if (includeGlitch) {                                        lineArray.push(newLine(upperRight[0] - c1[0], upperRight[1] + c1[1],                                           undefined, undefined,                                           upperRight[0] - c1cp2[0], upperRight[1] + c1cp2[1]));                    lineArray.push(newLine(upperRight[0] - l2[0], upperRight[1] + l2[1],                                           upperRight[0] - c2cp1[0], upperRight[1] + c2cp1[1],                                           undefined, undefined));                }                else {                                        lineArray.push(newLine(upperRight[0] - c1[0], upperRight[1] + c1[1],                               upperRight[0] - c2cp1[0], upperRight[1] + c2cp1[1],                               upperRight[0] - c1cp2[0], upperRight[1] + c1cp2[1]));                }                lineArray.push(newLine(upperRight[0] - c2[0], upperRight[1] + c2[1],                                       upperRight[0] - c3cp1[0], upperRight[1] + c3cp1[1],                                       upperRight[0] - c2cp2[0], upperRight[1] + c2cp2[1]));                var leftDirectionX = (inputLowerRight.value ? lowerRight[0] - l1[1] : undefined);                var leftDirectionY = (inputLowerRight.value ? lowerRight[1] - l1[0] : undefined);                lineArray.push(newLine(upperRight[0] - c3[0], upperRight[1] + c3[1],                                       leftDirectionX, leftDirectionY,                                       upperRight[0] - c3cp2[0], upperRight[1] + c3cp2[1]));            }            else {                             lineArray.push(newLine(upperRight[0], upperRight[1],                                       undefined, undefined,                                       undefined, undefined));            }            if (inputLowerRight.value == true) {                // Section 2                lineArray.push(newLine(lowerRight[0] - l1[1], lowerRight[1] - l1[0],                                       lowerRight[0] - c1cp1[1], lowerRight[1] - c1cp1[0],                                       undefined, undefined));                                if (includeGlitch) {                    lineArray.push(newLine(lowerRight[0] - c1[1], lowerRight[1] - c1[0],                                           undefined, undefined,                                           lowerRight[0] - c1cp2[1], lowerRight[1] - c1cp2[0]));                    lineArray.push(newLine(lowerRight[0] - l2[1], lowerRight[1] - l2[0],                                           lowerRight[0] - c2cp1[1], lowerRight[1] - c2cp1[0],                                           undefined, undefined));                }                else {                                        lineArray.push(newLine(lowerRight[0] - c1[1], lowerRight[1] - c1[0],                                           lowerRight[0] - c2cp1[1], lowerRight[1] - c2cp1[0],                                           lowerRight[0] - c1cp2[1], lowerRight[1] - c1cp2[0]));                }                lineArray.push(newLine(lowerRight[0] - c2[1], lowerRight[1] - c2[0],                                       lowerRight[0] - c3cp1[1], lowerRight[1] - c3cp1[0],                                       lowerRight[0] - c2cp2[1], lowerRight[1] - c2cp2[0]));                var leftDirectionX = (inputLowerLeft.value ? lowerLeft[0] + l1[0] : undefined);                var leftDirectionY = (inputLowerLeft.value ? lowerLeft[1] - l1[1] : undefined);                lineArray.push(newLine(lowerRight[0] - c3[1], lowerRight[1] - c3[0],                                       leftDirectionX, leftDirectionY,                                       lowerRight[0] - c3cp2[1], lowerRight[1] - c3cp2[0]));            }            else {                             lineArray.push(newLine(lowerRight[0], lowerRight[1],                                       undefined, undefined,                                       undefined, undefined));            }            if (inputLowerLeft.value == true) {                // Section 3                lineArray.push(newLine(lowerLeft[0] + l1[0], lowerLeft[1] - l1[1],                                       lowerLeft[0] + c1cp1[0], lowerLeft[1] - c1cp1[1],                                       undefined, undefined));                if (includeGlitch) {                                        lineArray.push(newLine(lowerLeft[0] + c1[0], lowerLeft[1] - c1[1],                                           undefined, undefined,                                           lowerLeft[0] + c1cp2[0], lowerLeft[1] - c1cp2[1]));                    lineArray.push(newLine(lowerLeft[0] + l2[0], lowerLeft[1] - l2[1],                                           lowerLeft[0] + c2cp1[0], lowerLeft[1] - c2cp1[1],                                           undefined, undefined));                }                else {                                        lineArray.push(newLine(lowerLeft[0] + c1[0], lowerLeft[1] - c1[1],                               lowerLeft[0] + c2cp1[0], lowerLeft[1] - c2cp1[1],                               lowerLeft[0] + c1cp2[0], lowerLeft[1] - c1cp2[1]));                }                lineArray.push(newLine(lowerLeft[0] + c2[0], lowerLeft[1] - c2[1],                                       lowerLeft[0] + c3cp1[0], lowerLeft[1] - c3cp1[1],                                       lowerLeft[0] + c2cp2[0], lowerLeft[1] - c2cp2[1]));                var leftDirectionX = (inputUpperLeft.value ? upperLeft[0] + l1[1] : undefined);                var leftDirectionY = (inputUpperLeft.value ? upperLeft[1] + l1[0] : undefined);                lineArray.push(newLine(lowerLeft[0] + c3[0], lowerLeft[1] - c3[1],                                       leftDirectionX, leftDirectionY,                                       lowerLeft[0] + c3cp2[0], lowerLeft[1] - c3cp2[1]));            }            else {                             lineArray.push(newLine(lowerLeft[0], lowerLeft[1],                                       undefined, undefined,                                       undefined, undefined));            }            if (inputUpperLeft.value == true) {                // Section 4                lineArray.push(newLine(upperLeft[0] + l1[1], upperLeft[1] + l1[0],                                       upperLeft[0] + c1cp1[1], upperLeft[1] + c1cp1[0],                                       undefined, undefined));                if (includeGlitch) {                                        lineArray.push(newLine(upperLeft[0] + c1[1], upperLeft[1] + c1[0],                                           undefined, undefined,                                           upperLeft[0] + c1cp2[1], upperLeft[1] + c1cp2[0]));                    lineArray.push(newLine(upperLeft[0] + l2[1], upperLeft[1] + l2[0],                                           upperLeft[0] + c2cp1[1], upperLeft[1] + c2cp1[0],                                           undefined, undefined));                }                else {                                        lineArray.push(newLine(upperLeft[0] + c1[1], upperLeft[1] + c1[0],                                           upperLeft[0] + c2cp1[1], upperLeft[1] + c2cp1[0],                                           upperLeft[0] + c1cp2[1], upperLeft[1] + c1cp2[0]));                }                            lineArray.push(newLine(upperLeft[0] + c2[1], upperLeft[1] + c2[0],                                       upperLeft[0] + c3cp1[1], upperLeft[1] + c3cp1[0],                                       upperLeft[0] + c2cp2[1], upperLeft[1] + c2cp2[0]));            }        }        var spi = new SubPathInfo();        spi.closed = true;        spi.operation = ShapeOperation.SHAPEADD;        spi.entireSubPath = lineArray;        var pathName = getUniqueName("iOS Rounded Rect", doc.pathItems);        var roundedRect = doc.pathItems.add(pathName, [spi]);        // Make the path into a "shape" layer        makeSolidFillAdjLayer(app.foregroundColor);        roundedRect.remove();    }    catch(e) {                ; // Do nothing	}};function newLine(anchorX, anchorY, leftDirectionX, leftDirectionY, rightDirectionX, rightDirectionY) {        var newLine;    try {        // Apparently, PathPointInfo objects don't support UnitValues, so accomodate document resolution        var scaleFactor = 1.0 / (resolution / 72.0);        newLine = new PathPointInfo;        newLine.kind = PointKind.CORNERPOINT;        newLine.anchor = new Array(anchorX * scaleFactor, anchorY * scaleFactor);        newLine.leftDirection = (typeof leftDirectionX === "undefined" || typeof leftDirectionY === "undefined" ?                                 newLine.anchor :                                 new Array(leftDirectionX * scaleFactor, leftDirectionY * scaleFactor));        newLine.rightDirection = (typeof rightDirectionX === "undefined" || typeof rightDirectionY === "undefined" ?                                 newLine.anchor :                                 new Array(rightDirectionX * scaleFactor, rightDirectionY * scaleFactor));    }    catch(e) {                ; // Do nothing	}        return newLine;}function makeSolidFillAdjLayer(solidColor) {        try {                var desc = new ActionDescriptor();        var adjLayer = new ActionReference();        adjLayer.putClass(sTID('contentLayer'));        desc.putReference(cTID('null'), adjLayer);            var fill = new ActionDescriptor();                var sc = new ActionDescriptor();                    var color = new ActionDescriptor();                    color.putDouble(cTID('Rd  '), solidColor.rgb.red);                    color.putDouble(cTID('Grn '), solidColor.rgb.green);                    color.putDouble(cTID('Bl  '), solidColor.rgb.blue);                sc.putObject(cTID('Clr '), cTID('RGBC'), color);            fill.putObject(cTID('Type'), sTID('solidColorLayer'), sc);        desc.putObject(cTID('Usng'), sTID('contentLayer'), fill);        executeAction(cTID('Mk  '), desc, DialogModes.NO);    }    catch(e) {                ; // Do nothing	}};function addGuidesAndTemplate(doc, originX, originY, size, includeGuides, includeTemplate) {        try {                // Add template shapes to their own group        var layerSet;        if (includeTemplate) {                        layerSet = doc.layerSets.add();            layerSet.name = getUniqueName("iOS Icon Template", doc.layerSets);            layerSet.opacity = 25;        }        var guides = [0.0,                     (68.0 / 1024.0),       // One article reasoned this value as 64.0, but it doesn't work with the final rounded corners in iOS 7                     (320.0 / 1024.0),                     (512.0 / 1024.0)];                var direction = 1;        var i = 0;        var count = 0;        do {                        var d = Math.round(guides[i] * size);            var h = (direction > 0 ? (originX + d) : ((originX + size) - d));            var v = (direction > 0 ? (originY + d) : ((originY + size) - d));                        if (includeGuides) {                                doc.guides.add(Direction.HORIZONTAL, UnitValue(v + " pixels"));                doc.guides.add(Direction.VERTICAL, UnitValue(h + " pixels"));            }            if (includeTemplate) {                // Don't add edges                if (d > 0.0) {                                        count++;                    var adjust = (direction > 0 ? -0.5 : 0.5);                    var adjustedV = Math.round(v) + adjust;                    var adjustedH = Math.round(h) + adjust;                    makeLine(originX, adjustedV, (originX + size), adjustedV);                    nameCurrentLayer("Horizontal Line " + count);                    makeLine(adjustedH, originY, adjustedH, (originY + size));                    nameCurrentLayer("Vertical Line " + count);                }            }                        if (i >= (guides.length - 1)) {                            direction = -1;            }            i += direction;                    } while (i > -1);        if (includeTemplate) {                        var centerX = originX + (size * 0.5);            var centerY = originY + (size * 0.5);            makeCircle(centerX, centerY, (size - ((guides[1] * size) * 2.0)) * 0.5);            nameCurrentLayer("Outer Circle");                        var radius = (((size * guides[3]) - (size * guides[2])) * 2.0) / Math.sqrt(2.0);            makeCircle(centerX, centerY, radius);            nameCurrentLayer("Middle Circle");            makeCircle(centerX, centerY, (size - ((guides[2] * size) * 2.0)) * 0.5);            nameCurrentLayer("Inner Circle");            makeLine(originX, originY, (originX + size), (originY + size));            nameCurrentLayer("Diagonal 1");            makeLine(originX, (originY + size), (originX + size), originY);            nameCurrentLayer("Diagonal 2");                        closeGroup(layerSet);        }    }    catch(e) {                ; // Do nothing	}}function makeCircle(centerX, centerY, radius) {    try {                var left = centerX - radius;        var top = centerY - radius;        var right = centerX + radius;        var bottom = centerY + radius;        var desc1 = new ActionDescriptor();        var ref1 = new ActionReference();        ref1.putClass(sTID("contentLayer"));        desc1.putReference(cTID('null'), ref1);        var desc2 = new ActionDescriptor();        desc2.putUnitDouble(cTID('Opct'), cTID('#Prc'), 100);        var desc3 = new ActionDescriptor();        var desc4 = new ActionDescriptor();        desc4.putDouble(cTID('Rd  '), 0);        desc4.putDouble(cTID('Grn '), 0);        desc4.putDouble(cTID('Bl  '), 0);        desc3.putObject(cTID('Clr '), sTID("RGBColor"), desc4);        desc2.putObject(cTID('Type'), sTID("solidColorLayer"), desc3);        var desc5 = new ActionDescriptor();        desc5.putInteger(sTID("unitValueQuadVersion"), 1);        desc5.putUnitDouble(cTID('Top '), cTID('#Pxl'), top);        desc5.putUnitDouble(cTID('Left'), cTID('#Pxl'), left);        desc5.putUnitDouble(cTID('Btom'), cTID('#Pxl'), bottom);        desc5.putUnitDouble(cTID('Rght'), cTID('#Pxl'), right);        desc2.putObject(cTID('Shp '), cTID('Elps'), desc5);        var desc6 = new ActionDescriptor();        desc6.putInteger(sTID("strokeStyleVersion"), 2);        desc6.putBoolean(sTID("strokeEnabled"), true);        desc6.putBoolean(sTID("fillEnabled"), false);        desc6.putUnitDouble(sTID("strokeStyleLineWidth"), cTID('#Pnt'), 1.0 / (resolution / 72.0));     // Accomodate resolution in stroke width        desc6.putUnitDouble(sTID("strokeStyleLineDashOffset"), cTID('#Pnt'), 0);        desc6.putDouble(sTID("strokeStyleMiterLimit"), 100);        desc6.putEnumerated(sTID("strokeStyleLineCapType"), sTID("strokeStyleLineCapType"), sTID("strokeStyleButtCap"));        desc6.putEnumerated(sTID("strokeStyleLineJoinType"), sTID("strokeStyleLineJoinType"), sTID("strokeStyleMiterJoin"));        desc6.putEnumerated(sTID("strokeStyleLineAlignment"), sTID("strokeStyleLineAlignment"), sTID("strokeStyleAlignInside"));        desc6.putBoolean(sTID("strokeStyleScaleLock"), false);        desc6.putBoolean(sTID("strokeStyleStrokeAdjust"), false);        var list1 = new ActionList();        desc6.putList(sTID("strokeStyleLineDashSet"), list1);        desc6.putEnumerated(sTID("strokeStyleBlendMode"), cTID('BlnM'), cTID('Nrml'));        desc6.putUnitDouble(sTID("strokeStyleOpacity"), cTID('#Prc'), 100);        var desc7 = new ActionDescriptor();        var desc8 = new ActionDescriptor();        desc8.putDouble(cTID('Rd  '), 0);        desc8.putDouble(cTID('Grn '), 0);        desc8.putDouble(cTID('Bl  '), 0);        desc7.putObject(cTID('Clr '), sTID("RGBColor"), desc8);        desc6.putObject(sTID("strokeStyleContent"), sTID("solidColorLayer"), desc7);        desc6.putDouble(sTID("strokeStyleResolution"), 72);        desc2.putObject(sTID("strokeStyle"), sTID("strokeStyle"), desc6);        desc1.putObject(cTID('Usng'), sTID("contentLayer"), desc2);        executeAction(cTID('Mk  '), desc1, DialogModes.NO);     }    catch(e) {                ; // Do nothing	}}function makeLine(x1, y1, x2, y2) {        try {        var desc1 = new ActionDescriptor();        var ref1 = new ActionReference();        ref1.putClass(sTID("contentLayer"));        desc1.putReference(cTID('null'), ref1);        var desc2 = new ActionDescriptor();        desc2.putUnitDouble(cTID('Opct'), cTID('#Prc'), 100);        var desc3 = new ActionDescriptor();        var desc4 = new ActionDescriptor();        desc4.putDouble(cTID('Rd  '), 0);        desc4.putDouble(cTID('Grn '), 0);        desc4.putDouble(cTID('Bl  '), 0);        desc3.putObject(cTID('Clr '), sTID("RGBColor"), desc4);        desc2.putObject(cTID('Type'), sTID("solidColorLayer"), desc3);        var desc5 = new ActionDescriptor();        var desc6 = new ActionDescriptor();        desc6.putUnitDouble(cTID('Hrzn'), cTID('#Pxl'), x1);        desc6.putUnitDouble(cTID('Vrtc'), cTID('#Pxl'), y1);        desc5.putObject(cTID('Strt'), cTID('Pnt '), desc6);        var desc7 = new ActionDescriptor();        desc7.putUnitDouble(cTID('Hrzn'), cTID('#Pxl'), x2);        desc7.putUnitDouble(cTID('Vrtc'), cTID('#Pxl'), y2);        desc5.putObject(cTID('End '), cTID('Pnt '), desc7);        desc5.putUnitDouble(cTID('Wdth'), cTID('#Pxl'), 1);        desc2.putObject(cTID('Shp '), cTID('Ln  '), desc5);        var desc8 = new ActionDescriptor();        desc8.putInteger(sTID("strokeStyleVersion"), 2);        desc8.putBoolean(sTID("strokeEnabled"), false);        desc8.putBoolean(sTID("fillEnabled"), true);        desc8.putUnitDouble(sTID("strokeStyleLineWidth"), cTID('#Pnt'), 1);        desc8.putUnitDouble(sTID("strokeStyleLineDashOffset"), cTID('#Pnt'), 0);        desc8.putDouble(sTID("strokeStyleMiterLimit"), 100);        desc8.putEnumerated(sTID("strokeStyleLineCapType"), sTID("strokeStyleLineCapType"), sTID("strokeStyleButtCap"));        desc8.putEnumerated(sTID("strokeStyleLineJoinType"), sTID("strokeStyleLineJoinType"), sTID("strokeStyleMiterJoin"));        desc8.putEnumerated(sTID("strokeStyleLineAlignment"), sTID("strokeStyleLineAlignment"), sTID("strokeStyleAlignInside"));        desc8.putBoolean(sTID("strokeStyleScaleLock"), false);        desc8.putBoolean(sTID("strokeStyleStrokeAdjust"), false);        var list1 = new ActionList();        desc8.putList(sTID("strokeStyleLineDashSet"), list1);        desc8.putEnumerated(sTID("strokeStyleBlendMode"), cTID('BlnM'), cTID('Nrml'));        desc8.putUnitDouble(sTID("strokeStyleOpacity"), cTID('#Prc'), 100);        var desc9 = new ActionDescriptor();        var desc10 = new ActionDescriptor();        desc10.putDouble(cTID('Rd  '), 0);        desc10.putDouble(cTID('Grn '), 0);        desc10.putDouble(cTID('Bl  '), 0);        desc9.putObject(cTID('Clr '), sTID("RGBColor"), desc10);        desc8.putObject(sTID("strokeStyleContent"), sTID("solidColorLayer"), desc9);        desc8.putDouble(sTID("strokeStyleResolution"), 72);        desc2.putObject(sTID("strokeStyle"), sTID("strokeStyle"), desc8);        desc1.putObject(cTID('Usng'), sTID("contentLayer"), desc2);        executeAction(cTID('Mk  '), desc1, DialogModes.NO);       }    catch(e) {                ; // Do nothing	}}function nameCurrentLayer(name) {     try {             var desc1 = new ActionDescriptor();        var ref1 = new ActionReference();        ref1.putEnumerated(cTID('Lyr '), cTID('Ordn'), cTID('Trgt'));        desc1.putReference(cTID('null'), ref1);        var desc2 = new ActionDescriptor();        desc2.putString(cTID('Nm  '), name);        desc1.putObject(cTID('T   '), cTID('Lyr '), desc2);        executeAction(cTID('setd'), desc1, DialogModes.NO);    }    catch(e) {                ; // Do nothing	}}// Creates a unique name for the arrayfunction getUniqueName(namePrefix, array) {        var uniqueName = "";    var uniqueIndex = 1;        var nameExists = false;    do {                uniqueName = namePrefix + " " + uniqueIndex;        nameExists = false;        for (var i = 0; i < array.length; i++) {                        if (array[i].name == uniqueName) {                                nameExists = true;                break;            }        }        uniqueIndex++;            } while (nameExists == true);    return uniqueName;}function saveSettings(){    try {                var desc = new ActionDescriptor();        desc.putInteger(kMSRRPreset, parseInt(inputPreset.selection));        desc.putString(kMSRRWidth, inputWidth.text);        desc.putString(kMSRRHeight, inputHeight.text);        desc.putString(kMSRRCornerRadius, inputCornerRadius.text);        desc.putBoolean(kMSRRUpperLeft, inputUpperLeft.value);        desc.putBoolean(kMSRRUpperRight, inputUpperRight.value);        desc.putBoolean(kMSRRLowerRight, inputLowerRight.value);        desc.putBoolean(kMSRRLowerLeft, inputLowerLeft.value);        desc.putBoolean(kMSRRIncludeGuides, inputIncludeGuides.value);        desc.putBoolean(kMSRRIncludeTemplate, inputIncludeTemplate.value);        desc.putBoolean(kMSRRIncludeGlitch, inputIncludeGlitch.value);        desc.putBoolean(kMSRRImprovedIconShape, inputImprovedIconShape.value);                app.putCustomOptions(kMSRRSettings, desc, true);    }    catch(e) {                ; // Do nothing	}}function getSettings(){    try {                var desc = app.getCustomOptions(kMSRRSettings);        inputPreset.selection = desc.getInteger(kMSRRPreset);        inputWidth.text = desc.getString(kMSRRWidth);        inputHeight.text = desc.getString(kMSRRHeight);        inputCornerRadius.text = desc.getString(kMSRRCornerRadius);        inputUpperLeft.value = desc.getBoolean(kMSRRUpperLeft);        inputUpperRight.value = desc.getBoolean(kMSRRUpperRight);        inputLowerRight.value = desc.getBoolean(kMSRRLowerRight);        inputLowerLeft.value = desc.getBoolean(kMSRRLowerLeft);        inputIncludeGuides.value = desc.getBoolean(kMSRRIncludeGuides);        inputIncludeTemplate.value = desc.getBoolean(kMSRRIncludeTemplate);        inputIncludeGlitch.value = desc.getBoolean(kMSRRIncludeGlitch);        inputImprovedIconShape.value = desc.getBoolean(kMSRRImprovedIconShape);    }    catch(e) {                ; // Do nothing	}}// ============================= // Functions related to closing a layer set/group// Thanks to: http://www.ps-scripts.com/bb/viewtopic.php?f=9&t=4852&p=22058&hilit=expand+group&sid=70e44b92410800e436271a7e3a7d58e2#p22058function closeGroup(layerSet) {        try {                var layerSetName = layerSet.name;         var layerSetOpacity = layerSet.opacity;         var layerSetBlendMode = layerSet.blendMode;                 docRef.activeLayer = layerSet;         ungroup();         groupSelected(layerSetName);         var closedLayerSet = activeDocument.activeLayer;         closedLayerSet.opacity = layerSetOpacity;         closedLayerSet.blendMode = layerSetBlendMode;     }    catch(e) {                ; // Do nothing	}} function ungroup() {         var m_Dsc01 = new ActionDescriptor();     var m_Ref01 = new ActionReference();     m_Ref01.putEnumerated( charIDToTypeID( "Lyr " ), charIDToTypeID( "Ordn" ), charIDToTypeID( "Trgt" ) );     m_Dsc01.putReference( charIDToTypeID( "null" ), m_Ref01 );     try {                executeAction( stringIDToTypeID( "ungroupLayersEvent" ), m_Dsc01, DialogModes.NO );     } catch(e) {        ; // Do nothing    } } function groupSelected(name) {        var m_Dsc01 = new ActionDescriptor();    var m_Ref01 = new ActionReference();    m_Ref01.putClass( stringIDToTypeID( "layerSection" ) );    m_Dsc01.putReference(  charIDToTypeID( "null" ), m_Ref01 );    var m_Ref02 = new ActionReference();    m_Ref02.putEnumerated( charIDToTypeID( "Lyr " ), charIDToTypeID( "Ordn" ), charIDToTypeID( "Trgt" ) );    m_Dsc01.putReference( charIDToTypeID( "From" ), m_Ref02 );    var m_Dsc02 = new ActionDescriptor();    m_Dsc02.putString( charIDToTypeID( "Nm  " ), name);    m_Dsc01.putObject( charIDToTypeID( "Usng" ), stringIDToTypeID( "layerSection" ), m_Dsc02 );    executeAction( charIDToTypeID( "Mk  " ), m_Dsc01, DialogModes.NO );        return activeDocument.activeLayer; } 